<!-- 
Docs:
- https://project-osrm.org/docs/v5.5.1/api/#general-options
- https://account.heigit.org/manage/key

Docs Geoapify
- https://myprojects.geoapify.com/api/d61op2KWTUdtcxdQuqjo/keys
- https://apidocs.geoapify.com/playground/routing/

TODO:
- Fazer com que aplicação detecte que motorista saiu do trajeto para recalcular a rota.
- Ao deletar passageiro ou destino, recalcular a rota deve inserir próxima parada nas coordenadas.
 -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>

    <!-- Tailwind -->
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

    <!-- Lodash -->
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>

    <!-- Axios -->
    <script src="https://unpkg.com/axios@1.9.0/dist/axios.min.js"></script>

    <!-- Leaflet -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script></script>

    <!-- Leaflet Routing Machine -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"
    />
    <script src="https://unpkg.com/leaflet@1.2.0/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>

    <!-- Mapbox Polyline -->
    <script src="https://unpkg.com/@mapbox/polyline@1.1.1/src/polyline.js"></script>

    <!-- Vue -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

    <!-- VueUse -->
    <script src="https://unpkg.com/@vueuse/shared"></script>
    <script src="https://unpkg.com/@vueuse/core"></script>

    <!-- Vuetify -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/vuetify@3.8.2/dist/vuetify.min.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/vuetify@3.8.2/dist/vuetify.min.js"></script>

    <script src="./assets/humanize.js"></script>
    <script src="./assets/coder.js"></script>
    <script src="./assets/axios-cache.js"></script>
  </head>
  <body>
    <div id="app">
      <div class="flex">
        <div class="grow">
          <leaflet style="height: 100vh" @ready="leafletHandle"></leaflet>
        </div>
        <div
          class=""
          style="
            min-width: 400px;
            max-width: 400px;
            height: 100vh;
            overflow: auto;
          "
        >
          <v-list elevation="1">
            <template v-for="(o, i) in routing.markers">
              <v-list-item>
                <template #default>
                  <div class="text-disabled font-italic text-body-2">
                    {{ o.type }}
                  </div>
                  <div class="font-weight-bold">{{ o.name }}</div>
                </template>
                <template #append>
                  <v-btn
                    v-if="['passenger', 'destination'].includes(o.type)"
                    color="success"
                    @click="() => {
                      routing.markerRemove(o);
                      routing.routeCalculate();
                    }"
                  >
                    Ok
                  </v-btn>
                </template>
              </v-list-item>
            </template>
          </v-list>
          <br />
          <template v-for="o in routing.response.routes">
            <div>
              Duração: {{ humanize.timeDuration(o.duration +
              (routing.markers.length * 60)) }}
            </div>
          </template>
          <pre>{{ routing.debug }}</pre>
        </div>
      </div>
    </div>

    <script type="module">
      import { faker } from "https://esm.sh/@faker-js/faker";

      const { createApp, ref, reactive, onMounted, computed } = Vue;
      const { createVuetify } = Vuetify;
      const { useGeolocation } = VueUse;

      const app = createApp({
        setup() {
          let map = null;

          const routing = reactive({
            busy: false,
            type: "driving",
            markers: [
              {
                id: faker.string.ulid(),
                name: "Van",
                type: "vehicle",
                distance: 0,
                coords: [-19.804979, -43.925504],
              },
              {
                id: faker.string.ulid(),
                name: faker.person.firstName(),
                type: "passenger",
                distance: 0,
                coords: [-19.802916176446278, -43.92603278160095],
              },
              {
                id: faker.string.ulid(),
                name: faker.person.firstName(),
                type: "passenger",
                distance: 0,
                coords: [-19.805959600055854, -43.93649876117706],
              },
              {
                id: faker.string.ulid(),
                name: faker.person.firstName(),
                type: "passenger",
                distance: 0,
                coords: [-19.807403060882788, -43.928677439689636],
              },
              {
                id: faker.string.ulid(),
                name: faker.person.firstName(),
                type: "passenger",
                distance: 0,
                coords: [-19.800084680319518, -43.93029749393464],
              },
              {
                id: faker.string.ulid(),
                name: faker.person.firstName(),
                type: "passenger",
                distance: 0,
                coords: [-19.80209853033214, -43.927116394042976],
              },
              {
                id: faker.string.ulid(),
                name: faker.person.firstName(),
                type: "passenger",
                distance: 0,
                coords: [-19.810446398349715, -43.92901539802551],
              },
              {
                id: faker.string.ulid(),
                name: "Escola Estadual Paschoal Comanducci",
                type: "destination",
                distance: 0,
                coords: [-19.80267138777249, -43.93539637327194],
              },
              {
                id: faker.string.ulid(),
                name: "Escola Municipal Acadêmico Vivaldi Moreira",
                type: "destination",
                distance: 0,
                coords: [-19.805207582058472, -43.9400178194046],
              },
              {
                id: faker.string.ulid(),
                name: "Escola Estadual Maria Coutinho",
                type: "destination",
                distance: 0,
                coords: [-19.80400636472945, -43.94369781017304],
              },
            ],
            markerCoord(marker, coord) {
              marker.coords = coord;
              marker.marker.setLatLng(coord);
            },
            markerAdd(data = {}) {
              data = {
                id: faker.string.ulid(),
                name: faker.person.firstName(),
                type: "passenger",
                coords: [0, 0],
                ...data,
              };
              routing.markers.splice(routing.markers.length - 1, 0, data);
              routing.markersSort();
              routing.render();
            },
            markerRemove(marker) {
              const index = routing.markers.indexOf(marker);
              routing.markers.splice(index, 1);
              routing.render();
            },
            markersSort() {
              const sortAlgorithm = (markerStart, markers) => {
                let items = [markerStart, ...markers];
                const returns = [];

                const itemsLength = items.length;
                for (let i = 0; i < itemsLength; i++) {
                  const itemCurr = items.shift();
                  itemCurr.distance = 0;
                  items = items
                    .map((item) => {
                      item.distance = routing.coordsDistance(
                        [itemCurr.coords.lat, itemCurr.coords.lng],
                        [...item.coords]
                      );
                      return item;
                    })
                    .sort((a, b) => a.distance - b.distance);

                  if (typeof items[0] == "undefined") continue;
                  returns.push(items[0]);
                }
                return returns;
              };

              const markersVehicle = routing.markers
                .filter((marker) => marker.type === "vehicle")
                .at(0);

              const markersPassenger = sortAlgorithm(
                markersVehicle,
                routing.markers.filter((marker) => marker.type === "passenger")
              );

              const markersDestination = sortAlgorithm(
                markersVehicle,
                routing.markers.filter(
                  (marker) => marker.type === "destination"
                )
              );

              routing.markers = [
                markersVehicle,
                ...markersPassenger,
                ...markersDestination,
              ];
            },
            polyline: [],
            response: { code: null, routes: [], waypoints: [] },
            debug: computed(() => {
              return {
                busy: routing.busy,
                // markers: routing.markers.map((o) => ({
                //   id: o.id,
                //   name: o.name,
                //   coords: o.coords,
                // })),
                // response: routing.response.routes[0],
              };
            }),
            coordsDistance([lat1, lng1], [lat2, lng2]) {
              const degToRad = (deg) => deg * (Math.PI / 180);
              const earthRadius = 6371; // Raio da Terra em quilômetros
              const dLat = degToRad(lat2 - lat1);
              const dLng = degToRad(lng2 - lng1);

              const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(degToRad(lat1)) *
                  Math.cos(degToRad(lat2)) *
                  Math.sin(dLng / 2) *
                  Math.sin(dLng / 2);

              const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
              return earthRadius * c; // Distância em quilômetros
            },
            async routeCalculate() {
              // map.eachLayer((layer) => {
              //   if (layer instanceof L.Polyline) {
              //     map.removeLayer(layer);
              //   }
              // });

              const services = {
                async geoapify() {
                  const opts = coder.decode([
                    "eyJjYWNoZSI6dHJ1ZSwibWV0aG9kIjoiZ2V0IiwidXJsIjoiaH",
                    "R0cHM6Ly9hcGkuZ2VvYXBpZnkuY29tL3YxL3JvdXRpbmciLCJw",
                    "YXJhbXMiOnsiYXBpS2V5IjoiZjY3ZTZmMDNhYzQ2NDU4ZTgxMG",
                    "E2NTA3ZTkzNGI1YmIifSwiaGVhZGVycyI6eyJDb250ZW50LVR5",
                    "cGUiOiJhcHBsaWNhdGlvbi9qc29uIn19",
                  ]);

                  opts.params.mode = "drive";
                  opts.params.details = "instruction_details";
                  opts.params.waypoints = routing.markers
                    .slice(0, 3)
                    .map((marker) => {
                      return marker.coords.join(",");
                    })
                    .join("|");

                  const resp = await axios(opts);

                  const polylineFull = [];
                  if (resp.data.features && Array.isArray(resp.data.features)) {
                    resp.data.features.map((feature) => {
                      feature.geometry.coordinates.map((coords) => {
                        coords.map((coord) => {
                          polylineFull.push([coord[1], coord[0]]);
                        });
                      });
                    });
                  }

                  return polylineFull;
                },
                async osm() {
                  const opts = {
                    method: "get",
                    url:
                      "https://routing.openstreetmap.de/routed-car/route/v1/driving/" +
                      routing.markers
                        .slice(0, 2)
                        .map((marker) => {
                          return marker.coords.join(",");
                        })
                        .join(";"),
                    params: {
                      overview: "full",
                      // geometries: "geojson",
                    },
                  };

                  const resp = await axios(opts);
                  let polylineFull = [];
                  resp.data.routes.map((route) => {
                    polylineFull = polyline.decode(route.geometry);
                  });
                  return polylineFull;
                },
              };

              const polylineFull = await services.geoapify();
              polylineFull.map((coord) => {
                routing.polyline.push(coord);
              });
              console.log(routing.polyline);

              const polyline = L.polyline(polylineFull, {
                color: "#0066cc",
                weight: 2,
                opacity: 0.8,
                lineJoin: "round",
                // dashArray: "10, 10",
                lineCap: "round",
              }).addTo(map);

              driverSimulator.init();
            },
            render() {
              // map.eachLayer((layer) => {
              //   if (layer instanceof L.Marker) {
              //     map.removeLayer(layer);
              //   }
              // });

              routing.markers.map((item) => {
                const icon = new L.Icon.Default();
                icon.options.shadowSize = [0, 0];
                item.marker = L.marker(item.coords, { draggable: true, icon });
                item.marker
                  .bindPopup(item.name, {
                    autoClose: false,
                    closeOnClick: false,
                  })
                  .openPopup();
                item.marker.addTo(map);
                item.marker.on("dragend", (ev) => {
                  item.coords = Object.values(ev.target.getLatLng());
                  routing.routeCalculate();
                });
                return { ...item };
              });

              // if (routing.response.routes.length > 0) {
              //   routing.response.routes.map((route, routeIndex) => {
              //     let routesFull = [];
              //     let routesPart = [];

              //     // geojson
              //     if (
              //       typeof route.geometry == "object" &&
              //       Array.isArray(route.geometry.coordinates)
              //     ) {
              //       routesFull = route.geometry.coordinates.map(
              //         ([lng, lat]) => [lat, lng]
              //       );
              //     } else {
              //       route.legs.map((leg, legIndex) => {
              //         leg.steps.map((step, stepIndex) => {
              //           const distance = step.distance / 1000;
              //           const duration = step.duration / 60;
              //           step.intersections.map((inter, interIndex) => {
              //             const [lat, lng] = Object.values(inter.location);
              //             routesFull.push([lng, lat]);
              //           });
              //         });
              //       });
              //     }

              //     if (routesFull.length > 0) {
              //       routing.polylines.push(
              //         L.polyline(routesFull, {
              //           color: "#0066cc",
              //           weight: 2,
              //           opacity: 0.8,
              //           lineJoin: "round",
              //           // dashArray: "10, 10",
              //           lineCap: "round",
              //         }).addTo(map)
              //       );

              //       routesPart = (() => {
              //         if (typeof routing.markers[1] == "undefined") return [];
              //         const markerTargetCoords = routing.markers[1].coords;
              //         const routesFullDistances = routesFull.map(([lat, lng]) =>
              //           routing.coordsDistance(
              //             [markerTargetCoords[0], markerTargetCoords[1]],
              //             [lat, lng]
              //           )
              //         );
              //         const routesFullLower = routesFullDistances.reduce(
              //           (prev, curr) => (prev < curr ? prev : curr)
              //         );
              //         const routesFullLowerIndex =
              //           routesFullDistances.indexOf(routesFullLower);
              //         return routesFull.slice(0, routesFullLowerIndex);
              //       })();

              //       if (routesPart.length > 0) {
              //         routing.polylines.push(
              //           L.polyline(routesPart, {
              //             color: "#00ff00",
              //             weight: 4,
              //             opacity: 0.8,
              //             lineJoin: "round",
              //             // dashArray: "10, 10",
              //             lineCap: "round",
              //           }).addTo(map)
              //         );
              //       }
              //     }
              //   });
              // }
            },
            onUpdate() {
              const vehicle = routing.markers
                .filter((o) => o.type == "vehicle")
                .at(0);
              const passengers = routing.markers.filter((o) =>
                ["passenger", "destination"].includes(o.type)
              );
              passengers.map((item) => {
                item.distance = routing.coordsDistance(
                  [vehicle.coords[0], vehicle.coords[1]],
                  [item.coords[0], item.coords[1]]
                );
              });
            },
            init() {
              routing.markersSort();
              routing.render();
              routing.routeCalculate();
              setInterval(routing.onUpdate, 100);
            },
          });

          const leafletHandle = (scope) => {
            map = scope.map;
            routing.init();

            map.on("click", (ev) => {
              const coords = Object.values(ev.latlng);
              routing.markerAdd({ coords });
              // routing.routeCalculate();
              console.log(coords);
            });
          };

          // Simulate driver
          const driverSimulator = reactive({
            onStart() {},
            onUpdate({ progress }) {
              // console.log({ progress });
            },
            onEnd() {},
            init() {
              const marker = routing.markers[0];
              const polylineLength = routing.polyline;
              const updateTime = 500;
              const animateUpdate = () => {
                if (typeof routing.polyline[1] == "undefined") {
                  driverSimulator.onUpdate({ progress: 100 });
                  driverSimulator.onEnd({ progress: 100, marker });
                  return;
                }

                const coordNext = routing.polyline[1];
                routing.markerCoord(marker, coordNext);

                const progress =
                  100 - (routing.polyline.length * 100) / polylineLength;
                driverSimulator.onUpdate({ progress, marker });
                marker.marker._icon.style.transition = `all ${updateTime}ms linear`;

                routing.polyline.splice(0, 1);
                setTimeout(() => {
                  animateUpdate();
                }, updateTime);
              };

              driverSimulator.onStart({ progress: 0, marker });
              animateUpdate();
            },
          });

          return { humanize, routing, leafletHandle, driverSimulator };
        },
      });

      app.component("leaflet", {
        template: `<div style="position:relative; height:400px;">
          <div ref="mapRef" style="height: 100%">leaflet</div>
        </div>`,
        setup(props, ctx) {
          const mapData = reactive({
            lat: -19.804979,
            lng: -43.925504,
            zoom: 16,
            bounds: {
              _southWest: { lat: 0, lng: 0 },
              _northEast: { lat: 0, lng: 0 },
            },
            meta: {},
          });

          const mapRef = ref(null);

          onMounted(() => {
            const map = L.map(mapRef.value).setView(
              [mapData.lat, mapData.lng],
              mapData.zoom
            );
            L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(
              map
            );
            ctx.emit("ready", { el: mapRef.value, map, mapData, L });
            ["dragend", "zoomend"].map((evt) => {
              map.on(evt, (ev) => {
                const { lat, lng } = map.getCenter();
                mapData.lat = lat;
                mapData.lng = lng;
                mapData.zoom = map.getZoom();
                mapData.bounds = map.getBounds();
              });
            });
          });

          return { mapData, mapRef };
        },
      });

      app.use(createVuetify());
      app.mount("#app");
    </script>
  </body>
</html>
