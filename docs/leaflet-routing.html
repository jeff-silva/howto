<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>

    <!-- Tailwind -->
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>

    <!-- Lodash -->
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>

    <!-- Axios -->
    <script src="https://unpkg.com/axios@1.9.0/dist/axios.min.js"></script>

    <!-- Leaflet -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <script></script>

    <!-- Leaflet Routing Machine -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"
    />
    <script src="https://unpkg.com/leaflet@1.2.0/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>

    <!-- Mapbox Polyline -->
    <!-- <script src="https://unpkg.com/@mapbox/polyline@1.1.1/src/polyline.js"></script> -->

    <!-- Turf.js -->
    <script src="https://unpkg.com/@turf/turf@7.0.0/turf.min.js"></script>

    <!-- Vue -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

    <!-- VueUse -->
    <script src="https://unpkg.com/@vueuse/shared"></script>
    <script src="https://unpkg.com/@vueuse/core"></script>

    <!-- Vuetify -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/vuetify@3.8.2/dist/vuetify.min.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/vuetify@3.8.2/dist/vuetify.min.js"></script>

    <script src="./assets/humanize.js"></script>
    <script src="./assets/coder.js"></script>
    <script src="./assets/axios-cache.js"></script>
    <script src="./assets/game-input.js"></script>
    <script src="./assets/app-layout.vue.js"></script>

    <style>
      [test],
      [test] * {
        outline: dashed 1px red;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <app-layout
        drawer-width="350px"
        :actions="(scope) => [
          {
            text: 'Snackbar',
            onClick() {
              for(let i=1; i<=2; i++) {
                scope.snackbar.add({
                  text: `Snackbar ${i}`,
                  actions: (scope) => [
                    {
                      text: '123',
                      onClick() {
                        console.log(scope.item)
                      },
                    },
                  ],
                });
              }
            },
          },
          {
            text: 'Confirm',
            onClick() {
              scope.dialog.create({
                title: 'Confirmação',
                actions: [
                  {
                    text: 'Sim',
                    color: 'success',
                    onClick() {
                      console.log('sim');
                      scope.dialog.close();
                    },
                  },
                  {
                    text: 'Não',
                    color: 'error',
                    onClick() {
                      console.log('não');
                      scope.dialog.close();
                    },
                  },
                ],
              });
            },
          },
        ]"
      >
        <template #drawer>
          <v-list elevation="1">
            <template v-for="(o, i) in routing.markers">
              <v-list-item>
                <template #default>
                  <div class="text-disabled font-italic text-body-2">
                    {{ o.type }}
                  </div>
                  <div class="font-weight-bold">{{ o.name }}</div>
                </template>
                <template #append>
                  <v-btn
                    v-if="['passenger', 'destination'].includes(o.type)"
                    color="success"
                    @click="() => {
                      routing.markerRemove(o);
                      routing.routeCalculate();
                    }"
                  >
                    Ok
                  </v-btn>
                </template>
              </v-list-item>
            </template>
          </v-list>
          <br />
          <template v-for="o in routing.response.routes">
            <div>
              Duração: {{ humanize.timeDuration(o.duration +
              (routing.markers.length * 60)) }}
            </div>
          </template>
          <pre>{{ routing.debug }}</pre>
        </template>

        <!-- <template #header>isso é o header</template> -->

        <template #default="scope">
          <leaflet
            v-if="scope.view.ready"
            :style="{ width: '100%', height: scope.content.height, zIndex: 1 }"
            @ready="leafletHandle"
          ></leaflet>
        </template>

        <!-- <template #footer>isso é o footer</template>
        <template #actions>isso é o actions</template> -->
      </app-layout>
      <!-- <div class="flex">
        <div class="grow">
          <leaflet
            style="height: 100vh"
            @ready="leafletHandle"
            @change="(scope) => {
              console.clear();
              console.log(JSON.stringify(scope.mapData, null, 2));
            }"
          ></leaflet>
        </div>
        <div
          class=""
          style="
            min-width: 400px;
            max-width: 400px;
            height: 100vh;
            overflow: auto;
          "
        >
          <v-list elevation="1">
            <template v-for="(o, i) in routing.markers">
              <v-list-item>
                <template #default>
                  <div class="text-disabled font-italic text-body-2">
                    {{ o.type }}
                  </div>
                  <div class="font-weight-bold">{{ o.name }}</div>
                </template>
                <template #append>
                  <v-btn
                    v-if="['passenger', 'destination'].includes(o.type)"
                    color="success"
                    @click="() => {
                      routing.markerRemove(o);
                      routing.routeCalculate();
                    }"
                  >
                    Ok
                  </v-btn>
                </template>
              </v-list-item>
            </template>
          </v-list>
          <br />
          <template v-for="o in routing.response.routes">
            <div>
              Duração: {{ humanize.timeDuration(o.duration +
              (routing.markers.length * 60)) }}
            </div>
          </template>
          <pre>{{ routing.debug }}</pre>
        </div>
      </div>
      <template v-for="o in routing.markersNext">
        <v-snackbar :model-value="true" :timeout="-1">
          Confirmar {{ o.name }}
          <template #actions>
            <v-btn
              @click="() => {
              routing.markerRemove(o);
              routing.routeCalculate();
            }"
            >
              Ok
            </v-btn>
          </template>
        </v-snackbar>
      </template> -->
    </div>

    <script type="module">
      import { faker } from "https://esm.sh/@faker-js/faker";

      const { createApp, ref, reactive, onMounted, computed, h } = Vue;
      const { createVuetify } = Vuetify;
      const { useGeolocation } = VueUse;

      const app = createApp({
        setup() {
          let map = null;

          const routing = reactive({
            busy: false,
            type: "driving",
            markers: [
              {
                id: faker.string.ulid(),
                name: "Van",
                type: "vehicle",
                distance: 0,
                coords: [-19.804979, -43.925504],
              },
              {
                id: faker.string.ulid(),
                name: faker.person.firstName(),
                type: "passenger",
                distance: 0,
                coords: [-19.802916176446278, -43.92603278160095],
              },
              {
                id: faker.string.ulid(),
                name: faker.person.firstName(),
                type: "passenger",
                distance: 0,
                coords: [-19.805959600055854, -43.93649876117706],
              },
              {
                id: faker.string.ulid(),
                name: faker.person.firstName(),
                type: "passenger",
                distance: 0,
                coords: [-19.807403060882788, -43.928677439689636],
              },
              {
                id: faker.string.ulid(),
                name: faker.person.firstName(),
                type: "passenger",
                distance: 0,
                coords: [-19.800084680319518, -43.93029749393464],
              },
              {
                id: faker.string.ulid(),
                name: faker.person.firstName(),
                type: "passenger",
                distance: 0,
                coords: [-19.80209853033214, -43.927116394042976],
              },
              {
                id: faker.string.ulid(),
                name: faker.person.firstName(),
                type: "passenger",
                distance: 0,
                coords: [-19.810446398349715, -43.92901539802551],
              },
              {
                id: faker.string.ulid(),
                name: "Escola Estadual Paschoal Comanducci",
                type: "destination",
                distance: 0,
                coords: [-19.80267138777249, -43.93539637327194],
              },
              {
                id: faker.string.ulid(),
                name: "Escola Municipal Acadêmico Vivaldi Moreira",
                type: "destination",
                distance: 0,
                coords: [-19.805207582058472, -43.9400178194046],
              },
              {
                id: faker.string.ulid(),
                name: "Escola Estadual Maria Coutinho",
                type: "destination",
                distance: 0,
                coords: [-19.80400636472945, -43.94369781017304],
              },
            ],
            markerCoord(marker, coord) {
              marker.coords = coord;
              marker.marker.setLatLng(coord);
            },
            markerAdd(data = {}) {
              data = {
                id: faker.string.ulid(),
                name: faker.person.firstName(),
                type: "passenger",
                coords: [0, 0],
                ...data,
              };
              routing.markers.splice(routing.markers.length - 1, 0, data);
              routing.markersSort();
              routing.render();
            },
            markerRemove(marker) {
              const index = routing.markers.indexOf(marker);
              routing.markers.splice(index, 1);
              marker.marker.remove();
              routing.render();
            },
            markersSort() {
              const sortAlgorithm = (markerStart, markers) => {
                let items = [markerStart, ...markers];
                const returns = [];

                const itemsLength = items.length;
                for (let i = 0; i < itemsLength; i++) {
                  const itemCurr = items.shift();
                  itemCurr.distance = 0;
                  items = items
                    .map((item) => {
                      item.distance = routing.coordsDistance(
                        [itemCurr.coords.lat, itemCurr.coords.lng],
                        [...item.coords]
                      );
                      return item;
                    })
                    .sort((a, b) => a.distance - b.distance);

                  if (typeof items[0] == "undefined") continue;
                  returns.push(items[0]);
                }
                return returns;
              };

              const markersVehicle = routing.markers
                .filter((marker) => marker.type === "vehicle")
                .at(0);

              const markersPassenger = sortAlgorithm(
                markersVehicle,
                routing.markers.filter((marker) => marker.type === "passenger")
              );

              const markersDestination = sortAlgorithm(
                markersVehicle,
                routing.markers.filter(
                  (marker) => marker.type === "destination"
                )
              );

              routing.markers = [
                markersVehicle,
                ...markersPassenger,
                ...markersDestination,
              ];
            },
            markersNext: computed(() => {
              const vehicle = routing.markers
                .filter((o) => o.type == "vehicle")
                .at(0);

              return routing.markers
                .filter((o) => ["passenger", "destination"].includes(o.type))
                .filter((o) => {
                  const distance = routing.coordsDistance(
                    vehicle.coords,
                    o.coords
                  );
                  return distance < 0.05;
                });
            }),
            polyline: [],
            response: { code: null, routes: [], waypoints: [] },
            debug: computed(() => {
              return {
                busy: routing.busy,
                markersNext: routing.markersNext.length,
                // markers: routing.markers.map((o) => ({
                //   id: o.id,
                //   name: o.name,
                //   coords: o.coords,
                // })),
                // response: routing.response.routes[0],
              };
            }),
            coordsDistance([lat1, lng1], [lat2, lng2]) {
              const degToRad = (deg) => deg * (Math.PI / 180);
              const earthRadius = 6371; // Raio da Terra em quilômetros
              const dLat = degToRad(lat2 - lat1);
              const dLng = degToRad(lng2 - lng1);

              const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(degToRad(lat1)) *
                  Math.cos(degToRad(lat2)) *
                  Math.sin(dLng / 2) *
                  Math.sin(dLng / 2);

              const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
              return earthRadius * c; // Distância em quilômetros
            },
            async routeCalculate() {
              // map.eachLayer((layer) => {
              //   if (layer instanceof L.Polyline) {
              //     map.removeLayer(layer);
              //   }
              // });

              const services = {
                async geoapify() {
                  const opts = coder.decode([
                    "eyJjYWNoZSI6dHJ1ZSwibWV0aG9kIjoiZ2V0IiwidXJsIjoiaH",
                    "R0cHM6Ly9hcGkuZ2VvYXBpZnkuY29tL3YxL3JvdXRpbmciLCJw",
                    "YXJhbXMiOnsiYXBpS2V5IjoiZjY3ZTZmMDNhYzQ2NDU4ZTgxMG",
                    "E2NTA3ZTkzNGI1YmIifSwiaGVhZGVycyI6eyJDb250ZW50LVR5",
                    "cGUiOiJhcHBsaWNhdGlvbi9qc29uIn19",
                  ]);

                  opts.params.mode = "drive";
                  opts.params.details = "instruction_details";
                  opts.params.waypoints = routing.markers
                    .slice(0, 2)
                    .map((marker) => {
                      return marker.coords.join(",");
                    })
                    .join("|");

                  const resp = await axios(opts);

                  const polylineFull = [];
                  if (resp.data.features && Array.isArray(resp.data.features)) {
                    resp.data.features.map((feature) => {
                      feature.geometry.coordinates.map((coords) => {
                        coords.map((coord) => {
                          polylineFull.push([coord[1], coord[0]]);
                        });
                      });
                    });
                  }

                  return polylineFull;
                },
                async osm() {
                  const opts = {
                    method: "get",
                    url:
                      "https://routing.openstreetmap.de/routed-car/route/v1/driving/" +
                      routing.markers
                        .slice(0, 2)
                        .map((marker) => {
                          return marker.coords.join(",");
                        })
                        .join(";"),
                    params: {
                      overview: "full",
                      // geometries: "geojson",
                    },
                  };

                  const resp = await axios(opts);
                  let polylineFull = [];
                  resp.data.routes.map((route) => {
                    polylineFull = polyline.decode(route.geometry); // mapbox polyline
                  });
                  return polylineFull;
                },
                async tomtom() {
                  if (routing.markers.length < 2) {
                    return [];
                  }

                  const opts = coder.decode([
                    "eyJjYWNoZSI6dHJ1ZSwibWV0aG9kIjoicG9zdCIsInVybCI6Im",
                    "h0dHBzOi8vYXBpLnRvbXRvbS5jb20vcm91dGluZy8xL2NhbGN1",
                    "bGF0ZVJvdXRlL3tsb2NhdGlvbnN9L2pzb24iLCJwYXJhbXMiOn",
                    "sia2V5IjoiREFLUmMwVUJLa3lPZm9jZTlnZnZ6b2lKUk5nSXJH",
                    "cFIifSwiaGVhZGVycyI6eyJDb250ZW50LVR5cGUiOiJhcHBsaW",
                    "NhdGlvbi9qc29uIiwiYWNjZXB0IjoiKi8qIn0sImRhdGEiOnt9",
                    "fQ==",
                  ]);

                  opts.url = opts.url.replace(
                    "{locations}",
                    routing.markers
                      .slice(0, 2)
                      .map((o) => o.coords.join(","))
                      .join(":")
                  );

                  opts.data = {
                    supportingPoints: [],
                    avoidVignette: [],
                    avoidAreas: {
                      rectangles: [],
                    },
                  };

                  let polylineFull = [];
                  const resp = await axios(opts);
                  resp.data.routes.map((route, routeIndex) => {
                    route.legs.map((leg, legIndex) => {
                      leg.points.map((point, pointIndex) => {
                        polylineFull.push([point.latitude, point.longitude]);
                      });
                    });
                  });

                  return polylineFull;
                },
              };

              const polylineFull = await services.tomtom();
              polylineFull.map((coord) => {
                routing.polyline.push(coord);
              });

              const polyline = L.polyline(polylineFull, {
                color: "#0066cc",
                weight: 2,
                opacity: 0.8,
                lineJoin: "round",
                // dashArray: "10, 10",
                lineCap: "round",
              }).addTo(map);

              driverSimulator.init();
            },
            render() {
              // map.eachLayer((layer) => {
              //   if (layer instanceof L.Marker) {
              //     map.removeLayer(layer);
              //   }
              // });

              map.eachLayer((layer) => {
                if (layer instanceof L.Polyline) {
                  map.removeLayer(layer);
                }
              });

              L.polyline(routing.polyline, {
                color: "#0066cc",
                weight: 2,
                opacity: 0.8,
                lineJoin: "round",
                // dashArray: "10, 10",
                lineCap: "round",
              }).addTo(map);

              routing.markers.map((item) => {
                if (item.marker) return;
                const icon = new L.Icon.Default();
                icon.options.shadowSize = [0, 0];
                item.marker = L.marker(item.coords, { draggable: true, icon });
                item.marker
                  .bindPopup(item.name, {
                    autoClose: false,
                    closeOnClick: false,
                  })
                  .openPopup();
                item.marker.addTo(map);
                item.marker.on("dragend", (ev) => {
                  item.coords = Object.values(ev.target.getLatLng());
                  routing.markerCoord(item, item.coords);
                  // routing.routeCalculate();
                });
                return { ...item };
              });

              // if (routing.response.routes.length > 0) {
              //   routing.response.routes.map((route, routeIndex) => {
              //     let routesFull = [];
              //     let routesPart = [];

              //     // geojson
              //     if (
              //       typeof route.geometry == "object" &&
              //       Array.isArray(route.geometry.coordinates)
              //     ) {
              //       routesFull = route.geometry.coordinates.map(
              //         ([lng, lat]) => [lat, lng]
              //       );
              //     } else {
              //       route.legs.map((leg, legIndex) => {
              //         leg.steps.map((step, stepIndex) => {
              //           const distance = step.distance / 1000;
              //           const duration = step.duration / 60;
              //           step.intersections.map((inter, interIndex) => {
              //             const [lat, lng] = Object.values(inter.location);
              //             routesFull.push([lng, lat]);
              //           });
              //         });
              //       });
              //     }

              //     if (routesFull.length > 0) {
              //       routing.polylines.push(
              //         L.polyline(routesFull, {
              //           color: "#0066cc",
              //           weight: 2,
              //           opacity: 0.8,
              //           lineJoin: "round",
              //           // dashArray: "10, 10",
              //           lineCap: "round",
              //         }).addTo(map)
              //       );

              //       routesPart = (() => {
              //         if (typeof routing.markers[1] == "undefined") return [];
              //         const markerTargetCoords = routing.markers[1].coords;
              //         const routesFullDistances = routesFull.map(([lat, lng]) =>
              //           routing.coordsDistance(
              //             [markerTargetCoords[0], markerTargetCoords[1]],
              //             [lat, lng]
              //           )
              //         );
              //         const routesFullLower = routesFullDistances.reduce(
              //           (prev, curr) => (prev < curr ? prev : curr)
              //         );
              //         const routesFullLowerIndex =
              //           routesFullDistances.indexOf(routesFullLower);
              //         return routesFull.slice(0, routesFullLowerIndex);
              //       })();

              //       if (routesPart.length > 0) {
              //         routing.polylines.push(
              //           L.polyline(routesPart, {
              //             color: "#00ff00",
              //             weight: 4,
              //             opacity: 0.8,
              //             lineJoin: "round",
              //             // dashArray: "10, 10",
              //             lineCap: "round",
              //           }).addTo(map)
              //         );
              //       }
              //     }
              //   });
              // }
            },
            onUpdate() {
              const vehicle = routing.markers
                .filter((o) => o.type == "vehicle")
                .at(0);

              // Remove polyline parts
              routing.polyline.map((coord, coordIndex) => {
                const distance = routing.coordsDistance(vehicle.coords, coord);
                if (distance < 0.01) {
                  routing.polyline.splice(0, coordIndex);
                  routing.render();
                }
              });

              // const isOnroute = (() => {
              //   return false;
              //   const distanceMeters = 10; // Distance to route

              //   if (routing.polyline.length == 0) return false;
              //   const vehiclePoint = turf.point([...vehicle.coords].reverse());

              //   const routingPolyline = routing.polyline.map((coords) =>
              //     turf.point([...coords].reverse())
              //   );

              //   const polylinePoints = turf.featureCollection(routingPolyline);
              //   const nearest = turf.nearestPoint(vehiclePoint, polylinePoints);

              //   let pointDataSize = 3;
              //   let pointsDataStart = nearest.properties.featureIndex - 1;
              //   pointsDataStart = Math.max(0, pointsDataStart);
              //   let pointsDataFinal = pointsDataStart + pointDataSize;
              //   if (pointsDataFinal > routingPolyline.length) {
              //     pointsDataFinal = routingPolyline.length;
              //     pointsDataStart = routingPolyline.length - pointDataSize;
              //   }
              //   const pointsData = routingPolyline
              //     .slice(pointsDataStart, pointsDataFinal)
              //     .map((o, i) => {
              //       if (typeof routingPolyline[i + 1] == "undefined") return 0;
              //       const point1 = o.geometry.coordinates;
              //       const point2 = routingPolyline[i + 1].geometry.coordinates;
              //       const distance = turf.pointToLineDistance(
              //         vehiclePoint,
              //         [point1, point2],
              //         {
              //           units: "meters",
              //         }
              //       );
              //       return distance;
              //     })
              //     .filter((n) => n <= distanceMeters);

              //   return pointsData.length > 0;
              // })();

              // if (!isOnroute) {
              //   console.log("Out of route");
              // }
            },
            init() {
              routing.markersSort();
              routing.render();
              routing.routeCalculate();

              const updateHandle = () => {
                routing.onUpdate();
                requestAnimationFrame(updateHandle);
              };

              updateHandle();
            },
          });

          const leafletHandle = (scope) => {
            map = scope.map;
            routing.init();

            map.on("click", (ev) => {
              const coords = Object.values(ev.latlng);
              routing.markerAdd({ coords });
              // routing.routeCalculate();
              console.log(coords);
            });
          };

          // Simulate driver
          const driverSimulator = reactive({
            onStart() {},
            onUpdate({ progress }) {
              // console.log({ progress });
            },
            onEnd() {},
            init() {
              const marker = routing.markers[0];
              const polylineLength = routing.polyline;
              const updateTime = 500;
              const animateUpdate = () => {
                // if (typeof routing.polyline[1] == "undefined") {
                //   driverSimulator.onUpdate({ progress: 100 });
                //   driverSimulator.onEnd({ progress: 100, marker });
                //   return;
                // }
                // const coordNext = routing.polyline[1];
                // routing.markerCoord(marker, coordNext);
                // const progress =
                //   100 - (routing.polyline.length * 100) / polylineLength;
                // driverSimulator.onUpdate({ progress, marker });
                // marker.marker._icon.style.transition = `all ${updateTime}ms linear`;
                // routing.polyline.splice(0, 1);
                // setTimeout(() => {
                //   animateUpdate();
                // }, updateTime);
              };

              driverSimulator.onStart({ progress: 0, marker });
              animateUpdate();

              const input = new GameInput();
              const vehicleSpeed = 0.000005;
              const mapZoom = 19;

              input.on(["w", "ArrowUp"], (ev) => {
                marker.coords[0] += vehicleSpeed;
                routing.markerCoord(marker, marker.coords);
                map.setView(marker.coords, mapZoom);
              });

              input.on(["s", "ArrowDown"], (ev) => {
                marker.coords[0] -= vehicleSpeed;
                routing.markerCoord(marker, marker.coords);
                map.setView(marker.coords, mapZoom);
              });

              input.on(["a", "ArrowLeft"], (ev) => {
                marker.coords[1] -= vehicleSpeed;
                routing.markerCoord(marker, marker.coords);
                map.setView(marker.coords, mapZoom);
              });

              input.on(["d", "ArrowRight"], (ev) => {
                marker.coords[1] += vehicleSpeed;
                routing.markerCoord(marker, marker.coords);
                map.setView(marker.coords, mapZoom);
              });
            },
          });

          return { humanize, routing, leafletHandle, driverSimulator };
        },
      });

      app.component("app-layout", appLayout);

      app.component("leaflet", {
        template: `<div style="position:relative; height:400px;">
          <div ref="mapRef" style="height: 100%">leaflet</div>
        </div>`,
        setup(props, ctx) {
          const mapData = reactive({
            lat: -19.804979,
            lng: -43.925504,
            zoom: 16,
            bounds: {
              _southWest: { lat: 0, lng: 0 },
              _northEast: { lat: 0, lng: 0 },
            },
            meta: {},
          });

          const mapRef = ref(null);

          const mapDataSync = (map) => {
            const { lat, lng } = map.getCenter();
            mapData.lat = lat;
            mapData.lng = lng;
            mapData.zoom = map.getZoom();
            mapData.bounds = map.getBounds();
          };

          const scope = (merge = {}) => {
            return { el: mapRef.value, mapData, L, ...merge };
          };

          onMounted(() => {
            const map = L.map(mapRef.value).setView(
              [mapData.lat, mapData.lng],
              mapData.zoom
            );
            L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(
              map
            );

            mapDataSync(map);
            ctx.emit("ready", scope({ map }));
            ctx.emit("change", scope({ map }));

            ["dragend", "zoomend"].map((evt) => {
              map.on(evt, (ev) => {
                mapDataSync(map);
                ctx.emit("change", scope({ map }));
              });
            });

            window.addEventListener("resize", () => {
              mapDataSync(map);
              ctx.emit("change", scope({ map }));
            });
          });

          return { mapData, mapRef };
        },
      });

      app.use(
        createVuetify({
          icons: {
            defaultSet: "main",
            sets: {
              main: {
                component: (props) => {
                  return h("img", {
                    src: `https://api.iconify.design/${props.icon}.svg`,
                    style: {
                      width: (props.size || 24) + "px",
                      height: (props.size || 24) + "px",
                    },
                  });
                },
              },
            },
          },
        })
      );
      app.mount("#app");
    </script>
  </body>
</html>
<!-- 
Docs:
- https://project-osrm.org/docs/v5.5.1/api/#general-options
- https://account.heigit.org/manage/key

Docs Geoapify
- https://myprojects.geoapify.com/api/d61op2KWTUdtcxdQuqjo/keys
- https://apidocs.geoapify.com/playground/routing/

Docs Tomtom
- https://developer.tomtom.com/routing-api/api-explorer
- https://developer.tomtom.com/user/me/analytics

TODO:
- Fazer com que aplicação detecte que motorista saiu do trajeto para recalcular a rota.
 -->
